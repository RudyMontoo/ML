<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/backend/logging_setup.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/backend/logging_setup.py" />
              <option name="originalContent" value="import logging&#10;&#10;&#10;def setup_logger(name, log_file='server.log', level=logging.DEBUG):&#10;    # Create a custom logger&#10;    logger = logging.getLogger(name)&#10;&#10;    # Configure the custom logger&#10;    logger.setLevel(level)&#10;    file_handler = logging.FileHandler(log_file)&#10;    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')&#10;    file_handler.setFormatter(formatter)&#10;    logger.addHandler(file_handler)&#10;&#10;    return logger" />
              <option name="updatedContent" value="import logging&#10;&#10;&#10;def setup_logger(name, log_file='server.log', level=logging.DEBUG):&#10;    # Create a custom logger&#10;    logger = logging.getLogger(name)&#10;&#10;    # Configure the custom logger&#10;    logger.setLevel(level)&#10;    if not logger.handlers:&#10;        file_handler = logging.FileHandler(log_file)&#10;        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')&#10;        file_handler.setFormatter(formatter)&#10;        logger.addHandler(file_handler)&#10;&#10;    return logger" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/backend/server.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/backend/server.py" />
              <option name="originalContent" value="from fastapi import FastAPI, HTTPException&#10;from datetime import date&#10;import db_helper&#10;from typing import List&#10;from pydantic import BaseModel&#10;&#10;app = FastAPI()&#10;&#10;&#10;class Expense(BaseModel):&#10;    amount: float&#10;    category: str&#10;    notes: str&#10;&#10;&#10;class DateRange(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;&#10;&#10;@app.get(&quot;/expenses/{expense_date}&quot;, response_model=List[Expense])&#10;def get_expenses(expense_date: date):&#10;    expenses = db_helper.fetch_expenses_for_date(expense_date)&#10;    if expenses is None:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to retrieve expenses from the database.&quot;)&#10;&#10;    return expenses&#10;&#10;&#10;@app.post(&quot;/expenses/{expense_date}&quot;)&#10;def add_or_update_expense(expense_date: date, expenses:List[Expense]):&#10;    db_helper.delete_expenses_for_date(expense_date)&#10;    for expense in expenses:&#10;        db_helper.insert_expense(expense_date, expense.amount, expense.category, expense.notes)&#10;&#10;    return {&quot;message&quot;: &quot;Expenses updated successfully&quot;}&#10;&#10;&#10;@app.post(&quot;/analytics/&quot;)&#10;def get_analytics(date_range: DateRange):&#10;    data = db_helper.fetch_expense_summary(date_range.start_date, date_range.end_date)&#10;    if data is None:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to retrieve expense summary from the database.&quot;)&#10;&#10;    total = sum([row['total'] for row in data])&#10;&#10;    breakdown = {}&#10;    for row in data:&#10;        percentage = (row['total']/total)*100 if total != 0 else 0&#10;        breakdown[row['category']] = {&#10;            &quot;total&quot;: row['total'],&#10;            &quot;percentage&quot;: percentage&#10;        }&#10;&#10;    return breakdown" />
              <option name="updatedContent" value="from fastapi import FastAPI, HTTPException&#10;from datetime import date&#10;try:&#10;    from . import db_helper&#10;except ImportError:&#10;    import db_helper&#10;from typing import List&#10;from pydantic import BaseModel&#10;&#10;app = FastAPI()&#10;&#10;&#10;class Expense(BaseModel):&#10;    amount: float&#10;    category: str&#10;    notes: str&#10;&#10;&#10;class DateRange(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;&#10;&#10;@app.get(&quot;/expenses/{expense_date}&quot;, response_model=List[Expense])&#10;def get_expenses(expense_date: date):&#10;    expenses = db_helper.fetch_expenses_for_date(expense_date)&#10;    if expenses is None:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to retrieve expenses from the database.&quot;)&#10;&#10;    return expenses&#10;&#10;&#10;@app.post(&quot;/expenses/{expense_date}&quot;)&#10;def add_or_update_expense(expense_date: date, expenses: List[Expense]):&#10;    db_helper.delete_expenses_for_date(expense_date)&#10;    for expense in expenses:&#10;        db_helper.insert_expense(expense_date, expense.amount, expense.category, expense.notes)&#10;&#10;    return {&quot;message&quot;: &quot;Expenses updated successfully&quot;}&#10;&#10;&#10;@app.post(&quot;/analytics/&quot;)&#10;def get_analytics(date_range: DateRange):&#10;    data = db_helper.fetch_expense_summary(date_range.start_date, date_range.end_date)&#10;    if data is None:&#10;        raise HTTPException(status_code=500, detail=&quot;Failed to retrieve expense summary from the database.&quot;)&#10;&#10;    total = sum([row['total'] for row in data])&#10;&#10;    breakdown = {}&#10;    for row in data:&#10;        percentage = (row['total']/total)*100 if total != 0 else 0&#10;        breakdown[row['category']] = {&#10;            &quot;total&quot;: row['total'],&#10;            &quot;percentage&quot;: percentage&#10;        }&#10;&#10;    return breakdown" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/exercise_solution/backend/db_helper.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/exercise_solution/backend/db_helper.py" />
              <option name="originalContent" value="import mysql.connector&#10;from contextlib import contextmanager&#10;from logging_setup import setup_logger&#10;&#10;&#10;logger = setup_logger('db_helper')&#10;&#10;&#10;@contextmanager&#10;def get_db_cursor(commit=False):&#10;    connection = mysql.connector.connect(&#10;        host=&quot;localhost&quot;,&#10;        user=&quot;root&quot;,&#10;        password=&quot;root&quot;,&#10;        database=&quot;expense_manager&quot;&#10;    )&#10;&#10;    cursor = connection.cursor(dictionary=True)&#10;    yield cursor&#10;    if commit:&#10;        connection.commit()&#10;    cursor.close()&#10;    connection.close()&#10;&#10;&#10;def fetch_expenses_for_date(expense_date):&#10;    logger.info(f&quot;fetch_expenses_for_date called with {expense_date}&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&quot;SELECT * FROM expenses WHERE expense_date = %s&quot;, (expense_date,))&#10;        expenses = cursor.fetchall()&#10;        return expenses&#10;&#10;&#10;def delete_expenses_for_date(expense_date):&#10;    logger.info(f&quot;delete_expenses_for_date called with {expense_date}&quot;)&#10;    with get_db_cursor(commit=True) as cursor:&#10;        cursor.execute(&quot;DELETE FROM expenses WHERE expense_date = %s&quot;, (expense_date,))&#10;&#10;&#10;def insert_expense(expense_date, amount, category, notes):&#10;    logger.info(f&quot;insert_expense called with date: {expense_date}, amount: {amount}, category: {category}, notes: {notes}&quot;)&#10;    with get_db_cursor(commit=True) as cursor:&#10;        cursor.execute(&#10;            &quot;INSERT INTO expenses (expense_date, amount, category, notes) VALUES (%s, %s, %s, %s)&quot;,&#10;            (expense_date, amount, category, notes)&#10;        )&#10;&#10;&#10;def fetch_expense_summary(start_date, end_date):&#10;    logger.info(f&quot;fetch_expense_summary called with start: {start_date} end: {end_date}&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&#10;            '''SELECT category, SUM(amount) as total &#10;               FROM expenses WHERE expense_date&#10;               BETWEEN %s and %s  &#10;               GROUP BY category;''',&#10;            (start_date, end_date)&#10;        )&#10;        data = cursor.fetchall()&#10;        return data&#10;&#10;&#10;def fetch_monthly_expense_summary():&#10;    logger.info(f&quot;fetch_expense_summary_by_months&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&#10;            '''SELECT month(expense_date) as expense_month, &#10;               monthname(expense_date) as month_name,&#10;               sum(amount) as total FROM expenses&#10;               GROUP BY expense_month, month_name;&#10;            '''&#10;        )&#10;        data = cursor.fetchall()&#10;        return data&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # expenses = fetch_expenses_for_date(&quot;2024-09-30&quot;)&#10;    # print(expenses)&#10;    # # delete_expenses_for_date(&quot;2024-08-25&quot;)&#10;    # summary = fetch_expense_summary(&quot;2024-08-01&quot;, &quot;2024-08-05&quot;)&#10;    # for record in summary:&#10;    #     print(record)&#10;    print(fetch_monthly_expense_summary())&#10;" />
              <option name="updatedContent" value="import mysql.connector&#10;from contextlib import contextmanager&#10;try:&#10;    from .logging_setup import setup_logger&#10;except ImportError:&#10;    from backend.logging_setup import setup_logger&#10;&#10;&#10;logger = setup_logger('db_helper')&#10;&#10;&#10;@contextmanager&#10;def get_db_cursor(commit=False):&#10;    connection = mysql.connector.connect(&#10;        host=&quot;localhost&quot;,&#10;        user=&quot;root&quot;,&#10;        password=&quot;root&quot;,&#10;        database=&quot;expense_manager&quot;&#10;    )&#10;&#10;    cursor = connection.cursor(dictionary=True)&#10;    yield cursor&#10;    if commit:&#10;        connection.commit()&#10;    cursor.close()&#10;    connection.close()&#10;&#10;&#10;def fetch_expenses_for_date(expense_date):&#10;    logger.info(f&quot;fetch_expenses_for_date called with {expense_date}&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&quot;SELECT * FROM expenses WHERE expense_date = %s&quot;, (expense_date,))&#10;        expenses = cursor.fetchall()&#10;        return expenses&#10;&#10;&#10;def delete_expenses_for_date(expense_date):&#10;    logger.info(f&quot;delete_expenses_for_date called with {expense_date}&quot;)&#10;    with get_db_cursor(commit=True) as cursor:&#10;        cursor.execute(&quot;DELETE FROM expenses WHERE expense_date = %s&quot;, (expense_date,))&#10;&#10;&#10;def insert_expense(expense_date, amount, category, notes):&#10;    logger.info(f&quot;insert_expense called with date: {expense_date}, amount: {amount}, category: {category}, notes: {notes}&quot;)&#10;    with get_db_cursor(commit=True) as cursor:&#10;        cursor.execute(&#10;            &quot;INSERT INTO expenses (expense_date, amount, category, notes) VALUES (%s, %s, %s, %s)&quot;,&#10;            (expense_date, amount, category, notes)&#10;        )&#10;&#10;&#10;def fetch_expense_summary(start_date, end_date):&#10;    logger.info(f&quot;fetch_expense_summary called with start: {start_date} end: {end_date}&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&#10;            '''SELECT category, SUM(amount) as total &#10;               FROM expenses WHERE expense_date&#10;               BETWEEN %s and %s  &#10;               GROUP BY category;''',&#10;            (start_date, end_date)&#10;        )&#10;        data = cursor.fetchall()&#10;        return data&#10;&#10;&#10;def fetch_monthly_expense_summary():&#10;    logger.info(f&quot;fetch_expense_summary_by_months&quot;)&#10;    with get_db_cursor() as cursor:&#10;        cursor.execute(&#10;            '''SELECT month(expense_date) as expense_month, &#10;               monthname(expense_date) as month_name,&#10;               sum(amount) as total FROM expenses&#10;               GROUP BY expense_month, month_name;&#10;            '''&#10;        )&#10;        data = cursor.fetchall()&#10;        return data&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # expenses = fetch_expenses_for_date(&quot;2024-09-30&quot;)&#10;    # print(expenses)&#10;    # # delete_expenses_for_date(&quot;2024-08-25&quot;)&#10;    # summary = fetch_expense_summary(&quot;2024-08-01&quot;, &quot;2024-08-05&quot;)&#10;    # for record in summary:&#10;    #     print(record)&#10;    print(fetch_monthly_expense_summary())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/exercise_solution/frontend/add_update.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/exercise_solution/frontend/add_update.py" />
              <option name="originalContent" value="import streamlit as st&#10;from datetime import datetime&#10;import requests&#10;&#10;API_URL = &quot;http://localhost:8000&quot;&#10;&#10;&#10;def add_update_tab():&#10;    selected_date = st.date_input(&quot;Enter Date&quot;, datetime(2024, 8, 1), label_visibility=&quot;collapsed&quot;)&#10;    try:&#10;        response = requests.get(f&quot;{API_URL}/expenses/{selected_date}&quot;)&#10;        if response.status_code == 200:&#10;            existing_expenses = response.json()&#10;            # st.write(existing_expenses)&#10;        else:&#10;            st.error(&quot;Failed to retrieve expenses&quot;)&#10;            existing_expenses = []&#10;    except requests.exceptions.ConnectionError:&#10;        st.error(&quot;Could not connect to backend API. Please ensure the backend server is running on port 8000.&quot;)&#10;        return&#10;&#10;    categories = [&quot;Rent&quot;, &quot;Food&quot;, &quot;Shopping&quot;, &quot;Entertainment&quot;, &quot;Other&quot;]&#10;&#10;    with st.form(key=&quot;expense_form&quot;):&#10;        col1, col2, col3 = st.columns(3)&#10;        with col1:&#10;            st.text(&quot;Amount&quot;)&#10;        with col2:&#10;            st.text(&quot;Category&quot;)&#10;        with col3:&#10;            st.text(&quot;Notes&quot;)&#10;&#10;        expenses = []&#10;        for i in range(5):&#10;            if i &lt; len(existing_expenses):&#10;                amount = existing_expenses[i]['amount']&#10;                category = existing_expenses[i][&quot;category&quot;]&#10;                notes = existing_expenses[i][&quot;notes&quot;]&#10;            else:&#10;                amount = 0.0&#10;                category = &quot;Shopping&quot;&#10;                notes = &quot;&quot;&#10;&#10;            col1, col2, col3 = st.columns(3)&#10;            with col1:&#10;                amount_input = st.number_input(label=&quot;Amount&quot;, min_value=0.0, step=1.0, value=amount, key=f&quot;amount_{i}&quot;,&#10;                                               label_visibility=&quot;collapsed&quot;)&#10;            with col2:&#10;                category_input = st.selectbox(label=&quot;Category&quot;, options=categories, index=categories.index(category),&#10;                                              key=f&quot;category_{i}&quot;, label_visibility=&quot;collapsed&quot;)&#10;            with col3:&#10;                notes_input = st.text_input(label=&quot;Notes&quot;, value=notes, key=f&quot;notes_{i}&quot;, label_visibility=&quot;collapsed&quot;)&#10;&#10;            expenses.append({&#10;                'amount': amount_input,&#10;                'category': category_input,&#10;                'notes': notes_input&#10;            })&#10;&#10;        submit_button = st.form_submit_button()&#10;        if submit_button:&#10;            filtered_expenses = [expense for expense in expenses if expense['amount'] &gt; 0]&#10;            try:&#10;                response = requests.post(f&quot;{API_URL}/expenses/{selected_date}&quot;, json=filtered_expenses)&#10;                if response.status_code == 200:&#10;                    st.success(&quot;Expenses updated successfully!&quot;)&#10;                else:&#10;                    st.error(&quot;Failed to update expenses.&quot;)&#10;            except requests.exceptions.ConnectionError:&#10;                st.error(&quot;Could not connect to backend API. Please ensure the backend server is running on port 8000.&quot;)&#10;" />
              <option name="updatedContent" value="import streamlit as st&#10;from datetime import datetime&#10;import requests&#10;&#10;API_URL = &quot;http://localhost:8000&quot;&#10;&#10;&#10;def add_update_tab():&#10;    selected_date = st.date_input(&quot;Enter Date&quot;, datetime(2024, 8, 1), label_visibility=&quot;collapsed&quot;)&#10;    try:&#10;        response = requests.get(f&quot;{API_URL}/expenses/{selected_date}&quot;)&#10;        if response.status_code == 200:&#10;            existing_expenses = response.json()&#10;            # st.write(existing_expenses)&#10;        else:&#10;            st.error(&quot;Failed to retrieve expenses&quot;)&#10;            existing_expenses = []&#10;    except requests.exceptions.ConnectionError:&#10;        st.error(&quot;Could not connect to backend API. Please ensure the backend server is running on port 8000.&quot;)&#10;        return&#10;    except Exception as e:&#10;        st.error(f&quot;An unexpected error occurred: {e}&quot;)&#10;        return&#10;&#10;    categories = [&quot;Rent&quot;, &quot;Food&quot;, &quot;Shopping&quot;, &quot;Entertainment&quot;, &quot;Other&quot;]&#10;&#10;    with st.form(key=&quot;expense_form&quot;):&#10;        col1, col2, col3 = st.columns(3)&#10;        with col1:&#10;            st.text(&quot;Amount&quot;)&#10;        with col2:&#10;            st.text(&quot;Category&quot;)&#10;        with col3:&#10;            st.text(&quot;Notes&quot;)&#10;&#10;        expenses = []&#10;        for i in range(5):&#10;            if i &lt; len(existing_expenses):&#10;                amount = existing_expenses[i]['amount']&#10;                category = existing_expenses[i][&quot;category&quot;]&#10;                notes = existing_expenses[i][&quot;notes&quot;]&#10;            else:&#10;                amount = 0.0&#10;                category = &quot;Shopping&quot;&#10;                notes = &quot;&quot;&#10;&#10;            col1, col2, col3 = st.columns(3)&#10;            with col1:&#10;                amount_input = st.number_input(label=&quot;Amount&quot;, min_value=0.0, step=1.0, value=amount, key=f&quot;amount_{i}&quot;,&#10;                                               label_visibility=&quot;collapsed&quot;)&#10;            with col2:&#10;                category_input = st.selectbox(label=&quot;Category&quot;, options=categories, index=categories.index(category),&#10;                                              key=f&quot;category_{i}&quot;, label_visibility=&quot;collapsed&quot;)&#10;            with col3:&#10;                notes_input = st.text_input(label=&quot;Notes&quot;, value=notes, key=f&quot;notes_{i}&quot;, label_visibility=&quot;collapsed&quot;)&#10;&#10;            expenses.append({&#10;                'amount': amount_input,&#10;                'category': category_input,&#10;                'notes': notes_input&#10;            })&#10;&#10;        submit_button = st.form_submit_button()&#10;        if submit_button:&#10;            filtered_expenses = [expense for expense in expenses if expense['amount'] &gt; 0]&#10;            try:&#10;                response = requests.post(f&quot;{API_URL}/expenses/{selected_date}&quot;, json=filtered_expenses)&#10;                if response.status_code == 200:&#10;                    st.success(&quot;Expenses updated successfully!&quot;)&#10;                else:&#10;                    st.error(&quot;Failed to update expenses.&quot;)&#10;            except requests.exceptions.ConnectionError:&#10;                st.error(&quot;Could not connect to backend API. Please ensure the backend server is running on port 8000.&quot;)&#10;            except Exception as e:&#10;                st.error(f&quot;An unexpected error occurred: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/tests/backend/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PYTHON ADVANCED/5_project_two_expense_management/tests/backend/__init__.py" />
              <option name="updatedContent" value="# This file makes the tests/backend directory a Python package" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>